import numpy as np
import pandas as pd
import yfinance as yf
import datetime
from scipy.optimize import minimize
import matplotlib.pyplot as plt

start = datetime.datetime(2023,7,1)
end = datetime.datetime(2024,7,1)

#portfolio stocks
ticker_group = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')[0].Symbol.to_list()

#data and returns
stock_data = pd.DataFrame(yf.download(ticker_group, start=start, end=end)['Close']).dropna(axis=1)
log_returns = np.log(stock_data/stock_data.shift(1))

#sigma, a0, rMin
a0 = log_returns.mean()
sigma = log_returns.cov()

#rMin equal to sp500 log returns
SPY = yf.download(tickers = 'SPY', start=start, end=end)['Close']
log_returns_spy = np.log(SPY/SPY.shift(1))
MeanReturnsSpy = log_returns_spy.mean()
variance_spy = log_returns_spy.var()
rMin = log_returns_spy.mean()*1.01



#optimization proces

#base weights
w0 = []
for i in range (0, len(stock_data.columns)):
    x = 1/len(stock_data.columns)
    w0.append(x)
w0 = np.array(w0)

#bounds and constraints
def MinimumReturnConstraint(w):
    return np.dot(w, a0.values) - rMin


def SumToOneConstraint(w):
    return np.sum(w)-1

#function that should be minimized
def portfolio_variance_func (w):
    return np.dot(w.T, np.dot(sigma, w))

constraints = (
    {'type': 'ineq', 'fun': MinimumReturnConstraint},
    {'type': 'eq', 'fun': SumToOneConstraint}
)

bounds = []
for i in range(0,len(stock_data.columns)):
    bounds.append((0,1))

#minimizing
w_opt = minimize(portfolio_variance_func, w0, method='SLSQP', bounds=bounds, constraints = constraints)




#saving weights
optimized_weights_df = pd.DataFrame({
    'Ticker': stock_data.columns,
    'weight': w_opt.x,
})

optimized_weights_df.to_csv('optimized_weights_df.csv', index=False)



#testing the optimized portfolio
#dates
start_test = datetime.datetime(2024,7,1)
end_test = datetime.datetime(2025,7,1)

#data to test the optimized weights
stocks_test = optimized_weights_df['Ticker'].tolist()
weights_test = optimized_weights_df['weight'].tolist()
weights_test = np.array(weights_test)
data_df_test = yf.download(tickers=stocks_test, start=start_test, end=end_test)['Close'].dropna(axis=1)

#optimized portfolio variance and log returns, for out of sample data
#variance
log_returns_test = np.log(data_df_test/data_df_test.shift(1))
sigma_test = log_returns_test.cov()
portfolio_variance_test = np.dot(weights_test.T,np.dot(sigma_test, weights_test))
#returns
total_log_returns_test = np.log(data_df_test.iloc[-1]/data_df_test.iloc[0])
portfolio_log_returns_test = np.dot(weights_test.T, total_log_returns_test)


#SPY
#variance of SP500
SPY_df_test = yf.download(tickers='SPY', start=start_test, end=end_test)['Close']
SPY_log_returns_test = np.log(SPY_df_test/SPY_df_test.shift(1))
variance_SPY_test = SPY_log_returns_test.var()

#returns of SP500
total_log_returns_SPY_test = np.log(SPY_df_test.iloc[-1]/SPY_df_test.iloc[0])

#sharpe ratio SPY en optimized portfolio
rfr = np.log (1.04)
sharpe_optimized_portfolio = (portfolio_log_returns_test - rfr)/np.sqrt(portfolio_variance_test*252)
sharpe_SPY = (total_log_returns_SPY_test - rfr)/np.sqrt(variance_SPY_test*252)

print (f'Optimized Log Portfolio Returns: {portfolio_log_returns_test}')
print (f'Optimized Portfolio Annualized Variance: {portfolio_variance_test*252}')
print (f'Optimized Portfolio Sharpe Ratio: {sharpe_optimized_portfolio}')

print (f'SPY Log returns: {total_log_returns_SPY_test.values}')
print (f'SPY Annualized variance: {variance_SPY_test*252}')
print (f'SPY Sharpe Ratio: {sharpe_SPY.values}')


#plotted portfolio performance
time_series_optimized_portfolio = pd.Series(np.dot(log_returns_test, weights_test), index = log_returns_test.index)
cumulative_time_series_optimized_portfolio = np.exp(np.cumsum(time_series_optimized_portfolio))

cumulative_time_series_SPY = np.exp(np.cumsum(SPY_log_returns_test))



plt.plot(cumulative_time_series_optimized_portfolio, label='Optimized Portfolio')
plt.plot(cumulative_time_series_SPY, label='SPY')
plt.title('Cumulative growth optimized portfolio vs SPY')
plt.xlabel('Date')
plt.ylabel('Portfolio Value')
plt.legend()
plt.grid(True)
plt.show()

